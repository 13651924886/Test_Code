/**
  ****************************(C) COPYRIGHT 2016 DJI****************************
  * @file       gimbal_task.c/h
  * @brief      完成云台控制任务，由于云台使用陀螺仪解算出的角度，其范围在（-pi,pi）
  *             故而设置目标角度均为范围，存在许多对角度计算的函数。云台主要分为2种
  *             状态，陀螺仪控制状态是利用板载陀螺仪解算的姿态角进行控制，编码器控制
  *             状态是通过电机反馈的编码值控制的校准，此外还有校准状态，停止状态等。
  * @note       
  * @history
  *  Version    Date            Author          Modification
  *  V1.0.0     Dec-26-2018     RM              1. 完成
  *
  @verbatim
  ==============================================================================

  ==============================================================================
  @endverbatim
  ****************************(C) COPYRIGHT 2019 BDT****************************
  */
	
/************************* 头文件 ******************************/

#include "Gimbal_Task.h"

#include "main.h"

#include "arm_math.h"
#include "gimbal_behaviour.h"
#include "user_lib.h"
#include "INS_Task.h"
#include "remote_control.h"
#include "shoot.h"
#include "CAN_Receive.h"
#include "Detect_Task.h"
#include "pid.h"
#include "delay.h"
#include "LX_IMU.h"

/************************* 宏定义 ******************************************************************/

//电机编码值规整 0―8191
#define ECD_Format(ecd)         \
    {                           \
        if ((ecd) > ecd_range)  \
            (ecd) -= ecd_range; \
        else if ((ecd) < 0)     \
            (ecd) += ecd_range; \
    }

#define gimbal_total_pid_clear(gimbal_clear)                                                   \
    {                                                                                          \
        Gimbal_PID_clear(&(gimbal_clear)->gimbal_yaw_motor.gimbal_motor_absolute_angle_pid);   \
        Gimbal_PID_clear(&(gimbal_clear)->gimbal_yaw_motor.gimbal_motor_relative_angle_pid);   \
        PID_clear(&(gimbal_clear)->gimbal_yaw_motor.gimbal_motor_gyro_pid);                    \
                                                                                               \
        Gimbal_PID_clear(&(gimbal_clear)->gimbal_pitch_motor.gimbal_motor_absolute_angle_pid); \
        Gimbal_PID_clear(&(gimbal_clear)->gimbal_pitch_motor.gimbal_motor_relative_angle_pid); \
        PID_clear(&(gimbal_clear)->gimbal_pitch_motor.gimbal_motor_gyro_pid);                  \
    }

/*********************** 全局变量定义 ***************************************************************/

//云台控制所有相关数据
Gimbal_Control_t gimbal_control;

//发送的can 指令
//static int16_t Yaw_Can_Set_Current = 0, Pitch_Can_Set_Current = 0, Shoot_Can_Set_Current = 0;
int16_t Yaw_Can_Set_Current = 0, Pitch_Can_Set_Current = 0,Shoot_Can_Set_Current = 0;

		
/*********************** 静态函数声明 ***************************************************************/

//云台初始化
static void GIMBAL_Init(Gimbal_Control_t *gimbal_init);
//云台pid清零
static void Gimbal_PID_clear(Gimbal_PID_t *gimbal_pid_clear);
//云台状态设置
static void GIMBAL_Set_Mode(Gimbal_Control_t *gimbal_set_mode);
//云台数据更新
static void GIMBAL_Feedback_Update(Gimbal_Control_t *gimbal_feedback_update);
//云台状态切换保存数据，例如从陀螺仪状态切换到编码器状态保存目标值
static void GIMBAL_Mode_Change_Control_Transit(Gimbal_Control_t *gimbal_mode_change);
//计算云台电机相对中值的相对角度
static fp32 motor_ecd_to_angle_change(uint16_t ecd, uint16_t offset_ecd);
//设置云台控制量
static void GIMBAL_Set_Contorl(Gimbal_Control_t *gimbal_set_control);
//云台控制pid计算
static void GIMBAL_Control_loop(Gimbal_Control_t *gimbal_control_loop);

static void gimbal_motor_absolute_angle_control(Gimbal_Motor_t *gimbal_motor);
static void gimbal_motor_relative_angle_control(Gimbal_Motor_t *gimbal_motor);
static void gimbal_motor_raw_angle_control(Gimbal_Motor_t *gimbal_motor);

//在陀螺仪角度控制下，对控制的目标值进限制以防超最大相对角度
static void GIMBAL_absolute_angle_limit(Gimbal_Motor_t *gimbal_motor, fp32 add);
static void GIMBAL_relative_angle_limit(Gimbal_Motor_t *gimbal_motor, fp32 *add);
static void GIMBAL_PID_Init(Gimbal_PID_t *pid, fp32 maxout, fp32 intergral_limit, fp32 kp, fp32 ki, fp32 kd);
static fp32 GIMBAL_PID_Calc(Gimbal_PID_t *pid, fp32 get, fp32 set, fp32 error_delta);

static void calc_gimbal_cali(const Gimbal_Cali_t *gimbal_cali, uint16_t *yaw_offset, uint16_t *pitch_offset, fp32 *max_yaw, fp32 *min_yaw, fp32 *max_pitch, fp32 *min_pitch);

Shoot_System_t shoot_t;
PidTypeDef shoot_pid; 

static void shoot_initiate(Shoot_System_t *shoot_t)
{
			static const fp32 Shoot_speed_pid[3] = {SHOOT_SPEED_PID_KP, SHOOT_SPEED_PID_KI, SHOOT_SPEED_PID_KD};
			shoot_t->shoot_rc_ctrl =  get_remote_control_point();
			shoot_t->shoot_motor.motor_measure = get_Shoot_Motor_Measure_Point();
			shoot_t->shoot_motor.speed_set = -10;
	    PID_Init(&shoot_pid, PID_POSITION, Shoot_speed_pid, SHOOT_SPEED_PID_MAX_OUT, SHOOT_SPEED_PID_MAX_IOUT);

}

void shoot_setup(void)
{
	shoot_initiate(&shoot_t);
}

void shoot_task(void)
{   
	  static fp32 speed_fliter_1 = 0.0f;
    static fp32 speed_fliter_2 = 0.0f;
    static fp32 speed_fliter_3 = 0.0f;

    //拨弹轮电机速度滤波一下
    static const fp32 fliter_num[3] = {1.725709860247969f, -0.75594777109163436f, 0.030237910843665373f};

    //二阶低通滤波
    speed_fliter_1 = speed_fliter_2;
    speed_fliter_2 = speed_fliter_3;
    speed_fliter_3 = speed_fliter_2 * fliter_num[0] + speed_fliter_1 * fliter_num[1] 
										 + (shoot_t.shoot_motor.motor_measure->speed_rpm * Motor_RMP_TO_SPEED) * fliter_num[2];
    shoot_t.shoot_motor.speed = speed_fliter_3;
	  PID_Calc(&shoot_pid, shoot_t.shoot_motor.speed, shoot_t.shoot_motor.speed_set);
	  shoot_t.shoot_motor.given_current = (int16_t)(shoot_pid.out);
    Shoot_Can_Set_Current = shoot_t.shoot_motor.given_current;
	
	  if (switch_is_mid(shoot_t.shoot_rc_ctrl->rc.s[0]))
		{
				CAN_CMD_GIMBAL(0, 0, Shoot_Can_Set_Current, 0 );	
		}
		//检测遥控器拨扭是否朝下 ]
		if (switch_is_down(shoot_t.shoot_rc_ctrl->rc.s[0]))
		{
				CAN_CMD_GIMBAL(0, 0,0,0);
																	
		}
		//检测遥控器拨扭是否朝上 ]
		else if (switch_is_up(shoot_t.shoot_rc_ctrl->rc.s[0]))
		{
     	  CAN_CMD_GIMBAL(0, 0, Shoot_Can_Set_Current, 0 );

		}
}
/*********************** 函数定义 *********************************************************************************/

void GIMBAL_Setup(void)
{
    //云台初始化
    GIMBAL_Init(&gimbal_control);
	
    //判断电机是否都上线
//    while (toe_is_error(YawGimbalMotorTOE) || toe_is_error(PitchGimbalMotorTOE) || toe_is_error(TriggerMotorTOE) )
//    {
//        delay_ms(GIMBAL_CONTROL_TIME);
//        GIMBAL_Feedback_Update(&gimbal_control);             //云台数据反馈
//    }
}

void GIMBAL_task(void)
{
        GIMBAL_Set_Mode(&gimbal_control);                    //设置云台行为状态机 -> 设置云台电机状态机 -> 从而控制运动模式
        GIMBAL_Mode_Change_Control_Transit(&gimbal_control); //控制模式切换 控制数据过渡
        GIMBAL_Feedback_Update(&gimbal_control);             //更新yaw和pitch的absolute_angle绝对角度、relative_angle相对角度、motor_gyro角速度
        GIMBAL_Set_Contorl(&gimbal_control);                 //通过遥控器数据得到yaw和pitch的relative_angle_set/absolute_angle_set
        GIMBAL_Control_loop(&gimbal_control);                //云台yaw和pitch两轴的串级PID计算
				shoot_control_loop();        //射击任务控制循环
	
#if YAW_TURN		//YAW电机是否反装
        Yaw_Can_Set_Current = -gimbal_control.gimbal_yaw_motor.given_current;
#else
        Yaw_Can_Set_Current = gimbal_control.gimbal_yaw_motor.given_current;
#endif

#if PITCH_TURN	//PITCH电机是否反装
        Pitch_Can_Set_Current = -gimbal_control.gimbal_pitch_motor.given_current;
#else
        Pitch_Can_Set_Current = gimbal_control.gimbal_pitch_motor.given_current;
#endif

        //云台在遥控器掉线状态即relax 状态，can指令为0，不使用current设置为零的方法，是保证遥控器掉线一定使得云台停止
//        if (!(toe_is_error(YawGimbalMotorTOE) && toe_is_error(PitchGimbalMotorTOE) && toe_is_error(TriggerMotorTOE)))
//        {
//            if (toe_is_error(DBUSTOE))
//            {
//                CAN_CMD_GIMBAL(0, 0, 0, 0);
//            }
//            else
//            {
//                CAN_CMD_GIMBAL(Yaw_Can_Set_Current, Pitch_Can_Set_Current, Shoot_Can_Set_Current, 0);
//            }
//        }
				CAN_CMD_GIMBAL(Yaw_Can_Set_Current, Pitch_Can_Set_Current, Shoot_Can_Set_Current, 0 );

}


/**
  * @brief          云台校准设置，将校准的云台中值以及最小最大机械相对角度
  * @author         RM
  * @param[in]      yaw 中值
  * @param[in]      pitch 中值
  * @param[in]      yaw 最大相对角度
  * @param[in]      yaw 最小相对角度
  * @param[in]      pitch 最大相对角度
  * @param[in]      pitch 最小相对角度
  * @retval         返回空
  * @waring         这个函数使用到gimbal_control 静态变量导致函数不适用以上通用指针复用
  */
void set_cali_gimbal_hook(const uint16_t yaw_offset, const uint16_t pitch_offset, const fp32 max_yaw, const fp32 min_yaw, const fp32 max_pitch, const fp32 min_pitch)
{
    gimbal_control.gimbal_yaw_motor.offset_ecd = yaw_offset;
    gimbal_control.gimbal_yaw_motor.max_relative_angle = max_yaw;
    gimbal_control.gimbal_yaw_motor.min_relative_angle = min_yaw;

    gimbal_control.gimbal_pitch_motor.offset_ecd = pitch_offset;
    gimbal_control.gimbal_pitch_motor.max_relative_angle = max_pitch;
    gimbal_control.gimbal_pitch_motor.min_relative_angle = min_pitch;
}


/**
  * @brief          云台校准计算，将校准记录的最大 最小值 来计算云台 中值和最大最小机械角度
  * @author         RM
  * @param[in]      yaw 中值 指针
  * @param[in]      pitch 中值 指针
  * @param[in]      yaw 最大相对角度 指针
  * @param[in]      yaw 最小相对角度 指针
  * @param[in]      pitch 最大相对角度 指针
  * @param[in]      pitch 最小相对角度 指针
  * @retval         返回1 代表成功校准完毕， 返回0 代表未校准完
  * @waring         这个函数使用到gimbal_control 静态变量导致函数不适用以上通用指针复用
  */
bool_t cmd_cali_gimbal_hook(uint16_t *yaw_offset, uint16_t *pitch_offset, fp32 *max_yaw, fp32 *min_yaw, fp32 *max_pitch, fp32 *min_pitch)
{
    if (gimbal_control.gimbal_cali.step == 0)
    {
        gimbal_control.gimbal_cali.step = GIMBAL_CALI_START_STEP;
        //保存进入时候的数据，作为起始数据，来判断最大，最小值
        gimbal_control.gimbal_cali.max_pitch = gimbal_control.gimbal_pitch_motor.absolute_angle;
        gimbal_control.gimbal_cali.max_pitch_ecd = gimbal_control.gimbal_pitch_motor.gimbal_motor_measure->ecd;
        gimbal_control.gimbal_cali.max_yaw = gimbal_control.gimbal_yaw_motor.absolute_angle;
        gimbal_control.gimbal_cali.max_yaw_ecd = gimbal_control.gimbal_yaw_motor.gimbal_motor_measure->ecd;
        gimbal_control.gimbal_cali.min_pitch = gimbal_control.gimbal_pitch_motor.absolute_angle;
        gimbal_control.gimbal_cali.min_pitch_ecd = gimbal_control.gimbal_pitch_motor.gimbal_motor_measure->ecd;
        gimbal_control.gimbal_cali.min_yaw = gimbal_control.gimbal_yaw_motor.absolute_angle;
        gimbal_control.gimbal_cali.min_yaw_ecd = gimbal_control.gimbal_yaw_motor.gimbal_motor_measure->ecd;
        return 0;
    }
    else if (gimbal_control.gimbal_cali.step == GIMBAL_CALI_END_STEP)
    {
        calc_gimbal_cali(&gimbal_control.gimbal_cali, yaw_offset, pitch_offset, max_yaw, min_yaw, max_pitch, min_pitch);
        gimbal_control.gimbal_yaw_motor.offset_ecd = *yaw_offset;
        gimbal_control.gimbal_yaw_motor.max_relative_angle = *max_yaw;
        gimbal_control.gimbal_yaw_motor.min_relative_angle = *min_yaw;
        gimbal_control.gimbal_pitch_motor.offset_ecd = *pitch_offset;
        gimbal_control.gimbal_pitch_motor.max_relative_angle = *max_pitch;
        gimbal_control.gimbal_pitch_motor.min_relative_angle = *min_pitch;

        return 1;
    }
    else
    {
        return 0;
    }
}

//校准计算，相对最大角度，云台中值
static void calc_gimbal_cali(const Gimbal_Cali_t *gimbal_cali, uint16_t *yaw_offset, uint16_t *pitch_offset, fp32 *max_yaw, fp32 *min_yaw, fp32 *max_pitch, fp32 *min_pitch)
{
    if (gimbal_cali == NULL || yaw_offset == NULL || pitch_offset == NULL || max_yaw == NULL || min_yaw == NULL || max_pitch == NULL || min_pitch == NULL)
    {
        return;
    }

    int16_t temp_max_ecd = 0, temp_min_ecd = 0, temp_ecd = 0;

#if YAW_TURN
    temp_ecd = gimbal_cali->min_yaw_ecd - gimbal_cali->max_yaw_ecd;

    if (temp_ecd < 0)
    {
        temp_ecd += ecd_range;
    }
    temp_ecd = gimbal_cali->max_yaw_ecd + (temp_ecd / 2);

    ECD_Format(temp_ecd);
    *yaw_offset = temp_ecd;
    *max_yaw = -motor_ecd_to_angle_change(gimbal_cali->max_yaw_ecd, *yaw_offset);
    *min_yaw = -motor_ecd_to_angle_change(gimbal_cali->min_yaw_ecd, *yaw_offset);

#else

    temp_ecd = gimbal_cali->max_yaw_ecd - gimbal_cali->min_yaw_ecd;

    if (temp_ecd < 0)
    {
        temp_ecd += ecd_range;
    }
    temp_ecd = gimbal_cali->max_yaw_ecd - (temp_ecd / 2);

    ECD_Format(temp_ecd);
    *yaw_offset = temp_ecd;
    *max_yaw = motor_ecd_to_angle_change(gimbal_cali->max_yaw_ecd, *yaw_offset);
    *min_yaw = motor_ecd_to_angle_change(gimbal_cali->min_yaw_ecd, *yaw_offset);

#endif

#if PITCH_TURN

    temp_ecd = (int16_t)(gimbal_cali->max_pitch / Motor_Ecd_to_Rad);
    temp_max_ecd = gimbal_cali->max_pitch_ecd + temp_ecd;
    temp_ecd = (int16_t)(gimbal_cali->min_pitch / Motor_Ecd_to_Rad);
    temp_min_ecd = gimbal_cali->min_pitch_ecd + temp_ecd;

    ECD_Format(temp_max_ecd);
    ECD_Format(temp_min_ecd);

    temp_ecd = temp_max_ecd - temp_min_ecd;

    if (temp_ecd > Half_ecd_range)
    {
        temp_ecd -= ecd_range;
    }
    else if (temp_ecd < -Half_ecd_range)
    {
        temp_ecd += ecd_range;
    }

    if (temp_max_ecd > temp_min_ecd)
    {
        temp_min_ecd += ecd_range;
    }

    temp_ecd = temp_max_ecd - temp_ecd / 2;

    ECD_Format(temp_ecd);

    *pitch_offset = temp_ecd;

    *max_pitch = -motor_ecd_to_angle_change(gimbal_cali->max_pitch_ecd, *pitch_offset);
    *min_pitch = -motor_ecd_to_angle_change(gimbal_cali->min_pitch_ecd, *pitch_offset);

#else
    temp_ecd = (int16_t)(gimbal_cali->max_pitch / Motor_Ecd_to_Rad);
    temp_max_ecd = gimbal_cali->max_pitch_ecd - temp_ecd;
    temp_ecd = (int16_t)(gimbal_cali->min_pitch / Motor_Ecd_to_Rad);
    temp_min_ecd = gimbal_cali->min_pitch_ecd - temp_ecd;

    ECD_Format(temp_max_ecd);
    ECD_Format(temp_min_ecd);

    temp_ecd = temp_max_ecd - temp_min_ecd;

    if (temp_ecd > Half_ecd_range)
    {
        temp_ecd -= ecd_range;
    }
    else if (temp_ecd < -Half_ecd_range)
    {
        temp_ecd += ecd_range;
    }

    temp_ecd = temp_max_ecd - temp_ecd / 2;

    ECD_Format(temp_ecd);

    *pitch_offset = temp_ecd;

    *max_pitch = motor_ecd_to_angle_change(gimbal_cali->max_pitch_ecd, *pitch_offset);
    *min_pitch = motor_ecd_to_angle_change(gimbal_cali->min_pitch_ecd, *pitch_offset);
#endif
}

const Gimbal_Motor_t *get_yaw_motor_point(void)
{
    return &gimbal_control.gimbal_yaw_motor;
}

const Gimbal_Motor_t *get_pitch_motor_point(void)
{
    return &gimbal_control.gimbal_pitch_motor;
}
u8 chous7 = 0;
/************************************	GIMBAL_Init ****************************************************/
//初始化pid 数据指针
static void GIMBAL_Init(Gimbal_Control_t *gimbal_init)
{
/*** YAW,PITCH的PID参数 ****/
    static const fp32 Pitch_speed_pid[3] = {PITCH_SPEED_PID_KP, PITCH_SPEED_PID_KI, PITCH_SPEED_PID_KD};
    static const fp32 Yaw_speed_pid[3] = {YAW_SPEED_PID_KP, YAW_SPEED_PID_KI, YAW_SPEED_PID_KD};
		
/**** 电机数据指针获取 ****/
			//motor_yaw结构体变量，存放Yaw云台电机的实时反馈
    gimbal_init->gimbal_yaw_motor.gimbal_motor_measure = get_Yaw_Gimbal_Motor_Measure_Point();		
			//motor_pit结构体变量，存放Pitch云台电机的实时反馈
		gimbal_init->gimbal_pitch_motor.gimbal_motor_measure = get_Pitch_Gimbal_Motor_Measure_Point();
		
/**** 陀螺仪数据指针获取 ****/
			//INS_Angle[]存放yaw,pitch,roll的实时值
		gimbal_init->gimbal_INT_angle_point = get_LX_IMU_angle_point();
			//INS_gyro[]存放三轴角速度实时值
		gimbal_init->gimbal_INT_gyro_point = get_LX_IMU_gyro_point();
/**** 遥控器数据指针获取 ****/
		 //rc_ctrl结构体，存放遥控器实时通道值
    gimbal_init->gimbal_rc_ctrl = get_remote_control_point();	
		
/**** 初始化电机模式 ****/	
    gimbal_init->gimbal_yaw_motor.gimbal_motor_mode = gimbal_init->gimbal_yaw_motor.last_gimbal_motor_mode = GIMBAL_MOTOR_RAW;
    gimbal_init->gimbal_pitch_motor.gimbal_motor_mode = gimbal_init->gimbal_pitch_motor.last_gimbal_motor_mode = GIMBAL_MOTOR_RAW;
		
/**** 初始化YAW和Pitch的PID 并清除所有PID输出值和期望、反馈 ****/		
    //初始化yaw电机绝对角度环PID
    GIMBAL_PID_Init(&gimbal_init->gimbal_yaw_motor.gimbal_motor_absolute_angle_pid, \
		YAW_GYRO_ABSOLUTE_PID_MAX_OUT, YAW_GYRO_ABSOLUTE_PID_MAX_IOUT,\
		YAW_GYRO_ABSOLUTE_PID_KP,YAW_GYRO_ABSOLUTE_PID_KI, YAW_GYRO_ABSOLUTE_PID_KD);
		//初始化yaw电机相对角度环PID
    GIMBAL_PID_Init(&gimbal_init->gimbal_yaw_motor.gimbal_motor_relative_angle_pid,\
		YAW_ENCODE_RELATIVE_PID_MAX_OUT, YAW_ENCODE_RELATIVE_PID_MAX_IOUT,\
		YAW_ENCODE_RELATIVE_PID_KP,YAW_ENCODE_RELATIVE_PID_KI, YAW_ENCODE_RELATIVE_PID_KD);
		//初始化yaw电机角速度环PID
	  PID_Init(&gimbal_init->gimbal_yaw_motor.gimbal_motor_gyro_pid, PID_POSITION, Yaw_speed_pid,\
		YAW_SPEED_PID_MAX_OUT, YAW_SPEED_PID_MAX_IOUT);
    
		//初始化pitch电机绝对角度环PID
    GIMBAL_PID_Init(&gimbal_init->gimbal_pitch_motor.gimbal_motor_absolute_angle_pid,\
		PITCH_GYRO_ABSOLUTE_PID_MAX_OUT, PITCH_GYRO_ABSOLUTE_PID_MAX_IOUT,\
		PITCH_GYRO_ABSOLUTE_PID_KP, PITCH_GYRO_ABSOLUTE_PID_KI, PITCH_GYRO_ABSOLUTE_PID_KD);
		//初始化pitch电机相对角度环PID
    GIMBAL_PID_Init(&gimbal_init->gimbal_pitch_motor.gimbal_motor_relative_angle_pid,\
		PITCH_ENCODE_RELATIVE_PID_MAX_OUT, PITCH_ENCODE_RELATIVE_PID_MAX_IOUT,\
		PITCH_ENCODE_RELATIVE_PID_KP, PITCH_ENCODE_RELATIVE_PID_KI, PITCH_ENCODE_RELATIVE_PID_KD);
		//初始化pitch电机角速度环PID
    PID_Init(&gimbal_init->gimbal_pitch_motor.gimbal_motor_gyro_pid, PID_POSITION, Pitch_speed_pid,\
		PITCH_SPEED_PID_MAX_OUT, PITCH_SPEED_PID_MAX_IOUT);


    //清除云台PID的期望、反馈、输出值，全部清零，防止开机乱跑
    gimbal_total_pid_clear(gimbal_init);
		
/**** 根据实际装配结果来设置偏差offset和最大最小限位 ****/
		//设置云台relative angle的offset,根据实际装配结果来调试
		gimbal_init->gimbal_yaw_motor.offset_ecd 	 = GIMBAL_YAW_RELATIVE_ANGLE_OFFSET;    //去除了校准任务，自行设置校准量  2019-11-21 0:25:25 Stone
		gimbal_init->gimbal_pitch_motor.offset_ecd = GIMBAL_PITCH_RELATIVE_ANGLE_OFFSET;	//去除了校准任务，自行设置校准量  2019-11-21 0:25:25 Stone
		
		//设置云台relative angle最大值和最小值 即机械限位最大值
		gimbal_init->gimbal_yaw_motor.max_relative_angle = GIMBAL_YAW_MAX_RELATIVE_ANGLE;
		gimbal_init->gimbal_yaw_motor.min_relative_angle = GIMBAL_YAW_MIN_RELATIVE_ANGLE;
		gimbal_init->gimbal_pitch_motor.max_relative_angle = GIMBAL_PITCH_MAX_RELATIVE_ANGLE;
		gimbal_init->gimbal_pitch_motor.min_relative_angle = GIMBAL_PITCH_MIN_RELATIVE_ANGLE;
/**** 更新yaw和pitch的absolute_angle绝对角度、relative_angle相对角度、motor_gyro角速度 ****/		
    GIMBAL_Feedback_Update(gimbal_init);
		
		//更新YAW和PITCH期望为现在的反馈
    gimbal_init->gimbal_yaw_motor.absolute_angle_set = gimbal_init->gimbal_yaw_motor.absolute_angle;
    gimbal_init->gimbal_yaw_motor.relative_angle_set = gimbal_init->gimbal_yaw_motor.relative_angle;
    gimbal_init->gimbal_yaw_motor.motor_gyro_set = gimbal_init->gimbal_yaw_motor.motor_gyro;

    gimbal_init->gimbal_pitch_motor.absolute_angle_set = gimbal_init->gimbal_pitch_motor.absolute_angle;
    gimbal_init->gimbal_pitch_motor.relative_angle_set = gimbal_init->gimbal_pitch_motor.relative_angle;
    gimbal_init->gimbal_pitch_motor.motor_gyro_set = gimbal_init->gimbal_pitch_motor.motor_gyro;


		
		chous7 = 1;
}
/************************************	1.GIMBAL_Set_Mode ****************************************************/
//第一层GIMBAL_Set_Mode(Gimbal_Control_t *gimbal_set_mode)  																	[gimbal_task.c 			static]

//第二层	gimbal_behaviour_mode_set(gimbal_set_mode)
//				根据gimbal_behaviour的值去给gimbal_control->gimbal_yaw_motor.gimbal_motor_mode赋值	[gimbal_behaviour.c global]
//				根据gimbal_behaviour的值去给gimbal_control->gimbal_pitch_motor.gimbal_motor_mode赋值
//				如下3种状态值
// 				GIMBAL_MOTOR_RAW = 0, //电机原始值控制
//    		GIMBAL_MOTOR_GYRO,    //电机陀螺仪角度控制
//    		GIMBAL_MOTOR_ENCONDE, //电机编码值角度控制
//第三层		gimbal_behaviour_set(gimbal_mode_set)		根据gimbal_control->gimbal_rc_ctrl->rc.s[ModeChannel]
//					用于给全局变量gimbal_behaviour赋值																								[gimbal_behaviour.c static]
//					如下6种状态值
//  				GIMBAL_ZERO_FORCE = 0, 	//云台无力
// 				  GIMBAL_INIT=1          	//云台初始化
//  				GIMBAL_CALI=2           //云台校准
// 					GIMBAL_ABSOLUTE_ANGLE=3 //云台陀螺仪绝对角度控制
//  				GIMBAL_RELATIVE_ANGLE=4,//云台编码值相对角度控制
//  				GIMBAL_MOTIONLESS=5     //云台在遥控器无输入一段时间后保持不动，避免陀螺仪漂移

static void GIMBAL_Set_Mode(Gimbal_Control_t *gimbal_set_mode)
{
	//检测是否输入是否为空指针
	//如果是，则返回，防止错误设置云台模式
    if (gimbal_set_mode == NULL)
    {
        return;
    }
    gimbal_behaviour_mode_set(gimbal_set_mode);
}


/**************************** 2.GIMBAL_Mode_Change_Control_Transit 云台状态切换保存，用于状态切换过渡****************************/
static void GIMBAL_Mode_Change_Control_Transit(Gimbal_Control_t *gimbal_mode_change)
{
	
//1.检测是否输入是否为空指针
	
	//如果是，则返回，防止错误设置云台模式
    if (gimbal_mode_change == NULL)
    {
        return;
    }
		
//2.yaw电机状态机切换保存数据
		
		//RAW模式 保存电流期望，赋值为当前给定电流
    if (gimbal_mode_change->gimbal_yaw_motor.last_gimbal_motor_mode != GIMBAL_MOTOR_RAW && gimbal_mode_change->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_RAW)
    {
        gimbal_mode_change->gimbal_yaw_motor.raw_cmd_current = gimbal_mode_change->gimbal_yaw_motor.current_set = gimbal_mode_change->gimbal_yaw_motor.given_current;
    }
		//底盘跟随模式 保存绝对角度期望，赋值为当前绝对角度
    else if (gimbal_mode_change->gimbal_yaw_motor.last_gimbal_motor_mode != GIMBAL_MOTOR_GYRO && gimbal_mode_change->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_GYRO)
    {
        gimbal_mode_change->gimbal_yaw_motor.absolute_angle_set = gimbal_mode_change->gimbal_yaw_motor.absolute_angle;
    }
		//底盘不跟随模式 保存相对角度期望，赋值为当前相对角度
    else if (gimbal_mode_change->gimbal_yaw_motor.last_gimbal_motor_mode != GIMBAL_MOTOR_ENCONDE && gimbal_mode_change->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_ENCONDE)
    {
        gimbal_mode_change->gimbal_yaw_motor.relative_angle_set = gimbal_mode_change->gimbal_yaw_motor.relative_angle;
    }
		//状态保存
    gimbal_mode_change->gimbal_yaw_motor.last_gimbal_motor_mode = gimbal_mode_change->gimbal_yaw_motor.gimbal_motor_mode;

//3.pitch电机状态机切换保存数据
		//RAW模式 保存电流期望，赋值为当前给定电流
    if (gimbal_mode_change->gimbal_pitch_motor.last_gimbal_motor_mode != GIMBAL_MOTOR_RAW && gimbal_mode_change->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_RAW)
    {
        gimbal_mode_change->gimbal_pitch_motor.raw_cmd_current = gimbal_mode_change->gimbal_pitch_motor.current_set = gimbal_mode_change->gimbal_pitch_motor.given_current;
    }
		//底盘跟随模式 保存绝对角度期望，赋值为当前绝对角度
    else if (gimbal_mode_change->gimbal_pitch_motor.last_gimbal_motor_mode != GIMBAL_MOTOR_GYRO && gimbal_mode_change->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_GYRO)
    {
        gimbal_mode_change->gimbal_pitch_motor.absolute_angle_set = gimbal_mode_change->gimbal_pitch_motor.absolute_angle;
    }
		//底盘不跟随模式 保存相对角度期望，赋值为当前相对角度
    else if (gimbal_mode_change->gimbal_pitch_motor.last_gimbal_motor_mode != GIMBAL_MOTOR_ENCONDE && gimbal_mode_change->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_ENCONDE)
    {
        gimbal_mode_change->gimbal_pitch_motor.relative_angle_set = gimbal_mode_change->gimbal_pitch_motor.relative_angle;
    }
		//状态保存
    gimbal_mode_change->gimbal_pitch_motor.last_gimbal_motor_mode = gimbal_mode_change->gimbal_pitch_motor.gimbal_motor_mode;
}

/********************************** 3.GIMBAL_Feedback_Update 更新yaw和pitch的absolute_angle绝对角度、relative_angle相对角度、motor_gyro角速度 ****************************************************/
static void GIMBAL_Feedback_Update(Gimbal_Control_t *gimbal_feedback_update)
{
    if (gimbal_feedback_update == NULL)
    {
        return;
    }
/*************************************** 云台数据更新 ***********************************************************************************************/
		//功能解释:
		//更新yaw和pitch的absolute_angle绝对角度、relative_angle相对角度、motor_gyro角速度
		/*****************************************************************************************************************************************************/
		//参数解释:
		//gimbal_feedback_update->gimbal_INT_angle_point == INS_Angle       注:INS_Angle是INS_Angle[]数组首元素地址
		//INS_Angle[0]:yaw实时解算值,INS_Angle[1]:pitch实时解算值,INS_Angle[2]:roll实时解算值
		//gimbal_feedback_update->gimbal_INT_angle_point + INS_PITCH_ADDRESS_OFFSET = INS_Angle + 1 即INS_Angle[1]的地址
		
		//gimbal_feedback_update->gimbal_INT_gyro_point == INS_gyro					注:INS_gyro是INS_gyro[]数组首元素地址
		//INS_gyro[0]:x轴角速度实时值,INS_gyro[1]:y轴角速度实时值,INS_gyro[2]:z轴角速度实时值
		//gimbal_feedback_update->gimbal_INT_gyro_point + INS_GYRO_Y_ADDRESS_OFFSET = INS_gyro + 1  即INS_gyro[1]的地址
/*****************************************************************************************************************************************************/
//		gimbal_feedback_update->gimbal_pitch_motor.absolute_angle = ((*(gimbal_feedback_update->gimbal_INT_angle_point + INS_PITCH_ADDRESS_OFFSET))/32768.0f) * 180.0f;
//    gimbal_feedback_update->gimbal_pitch_motor.relative_angle = motor_ecd_to_angle_change(gimbal_feedback_update->gimbal_pitch_motor.gimbal_motor_measure->ecd,
//                                                                                          gimbal_feedback_update->gimbal_pitch_motor.offset_ecd);
//    gimbal_feedback_update->gimbal_pitch_motor.motor_gyro = (*(gimbal_feedback_update->gimbal_INT_gyro_point + INS_GYRO_Y_ADDRESS_OFFSET))/182.0f / 57.3f;

//    gimbal_feedback_update->gimbal_yaw_motor.absolute_angle = (((*(gimbal_feedback_update->gimbal_INT_angle_point + INS_YAW_ADDRESS_OFFSET))/32768.0f)* 180.0f)/57.3f;
//    gimbal_feedback_update->gimbal_yaw_motor.relative_angle = motor_ecd_to_angle_change(gimbal_feedback_update->gimbal_yaw_motor.gimbal_motor_measure->ecd,
//                                                                                        gimbal_feedback_update->gimbal_yaw_motor.offset_ecd);

//    gimbal_feedback_update->gimbal_yaw_motor.motor_gyro = (arm_cos_f32(gimbal_feedback_update->gimbal_pitch_motor.relative_angle) *
//																												(((*(gimbal_feedback_update->gimbal_INT_gyro_point + INS_GYRO_Z_ADDRESS_OFFSET))/32768.0f)*2000.0f / 57.3f)
//                                                        - arm_sin_f32(gimbal_feedback_update->gimbal_pitch_motor.relative_angle) * 
//																												(((*(gimbal_feedback_update->gimbal_INT_gyro_point + INS_GYRO_X_ADDRESS_OFFSET))/32768.0f)*2000.0f / 57.3f));
		//gimbal_feedback_update->gimbal_yaw_motor.motor_gyro = ((*(gimbal_feedback_update->gimbal_INT_gyro_point + INS_GYRO_Z_ADDRESS_OFFSET))/32768.0f)*2000.0f / 57.3f;
		gimbal_feedback_update->gimbal_pitch_motor.absolute_angle = (*(gimbal_feedback_update->gimbal_INT_angle_point + INS_PITCH_ADDRESS_OFFSET));
    gimbal_feedback_update->gimbal_pitch_motor.relative_angle = motor_ecd_to_angle_change(gimbal_feedback_update->gimbal_pitch_motor.gimbal_motor_measure->ecd,
                                                                                          gimbal_feedback_update->gimbal_pitch_motor.offset_ecd);
    gimbal_feedback_update->gimbal_pitch_motor.motor_gyro = -(*(gimbal_feedback_update->gimbal_INT_gyro_point + INS_GYRO_Y_ADDRESS_OFFSET));

    gimbal_feedback_update->gimbal_yaw_motor.absolute_angle = -(*(gimbal_feedback_update->gimbal_INT_angle_point + INS_YAW_ADDRESS_OFFSET));
    gimbal_feedback_update->gimbal_yaw_motor.relative_angle = motor_ecd_to_angle_change(gimbal_feedback_update->gimbal_yaw_motor.gimbal_motor_measure->ecd,
                                                                                        gimbal_feedback_update->gimbal_yaw_motor.offset_ecd);

    gimbal_feedback_update->gimbal_yaw_motor.motor_gyro = arm_cos_f32(gimbal_feedback_update->gimbal_pitch_motor.relative_angle) *
																												(*(gimbal_feedback_update->gimbal_INT_gyro_point + INS_GYRO_Z_ADDRESS_OFFSET))
                                                        - arm_sin_f32(gimbal_feedback_update->gimbal_pitch_motor.relative_angle) * 
																												(*(gimbal_feedback_update->gimbal_INT_gyro_point + INS_GYRO_X_ADDRESS_OFFSET));
}
//计算相对角度
//用于GIMBAL_Feedback_Update(Gimbal_Control_t *gimbal_feedback_update)
static fp32 motor_ecd_to_angle_change(uint16_t ecd, uint16_t offset_ecd)
{
    int32_t relative_ecd = ecd - offset_ecd;
    if (relative_ecd > Half_ecd_range) ///电机码盘值中值Half_ecd_range = 4096
    {
        relative_ecd -= ecd_range;		///电机码盘值最大值ecd_range = 8191
    }
    else if (relative_ecd < -Half_ecd_range)//-Half_ecd_range = -4096
    {
        relative_ecd += ecd_range;
    }

    return relative_ecd * Motor_Ecd_to_Rad;//电机编码值转化成角度值 rad
}

/**************************** 4.GIMBAL_Set_Contorl **********************************************************************************/
//云台控制量设置
//第一层GIMBAL_Set_Contorl(Gimbal_Control_t *gimbal_set_control)																	[gimbal_task.c 	global]

//第二层	gimbal_behaviour_control_set(&add_yaw_angle, &add_pitch_angle, gimbal_set_control)		[gimbal_behaviour.c global]
//				根据云台行为状态机gimbal_behaviour和遥控器的通道值来计算add_yaw_angle，add_pitch_angle
//				
//				根据云台电机状态机的模式来给yaw和pitch角度期望relative_angle_set/absolute_angle_set限幅
//	

/****************  第一层 云台控制量设置 ************************************************************************************/
static void GIMBAL_Set_Contorl(Gimbal_Control_t *gimbal_set_control)
{		
    if (gimbal_set_control == NULL)
    {
        return;
    }
		fp32 add_yaw_angle = 0.0f;		//yaw轴角度期望增量
    fp32 add_pitch_angle = 0.0f;	//pitch轴角度期望增量

/******************第二层 根据云台行为状态机gimbal_behaviour计算yaw和pitch期望add_yaw_angle、add_pitch_angle ***********************************/
		
    gimbal_behaviour_control_set(&add_yaw_angle, &add_pitch_angle, gimbal_set_control);
		
/******************第二层 根据云台电机状态机的模式来给yaw和pitch角度期望relative_angle_set/absolute_angle_set限幅 *******************************************************/
	/****************** yaw电机角度期望relative_angle_set/absolute_angle_set限幅 ***************************************/
			if (gimbal_set_control->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_RAW)
			{
					//raw模式下，直接发送控制值
					gimbal_set_control->gimbal_yaw_motor.raw_cmd_current = add_yaw_angle;
			}
			else if (gimbal_set_control->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_GYRO)
			{
					//gyro模式下，陀螺仪角度控制
					GIMBAL_absolute_angle_limit(&gimbal_set_control->gimbal_yaw_motor, add_yaw_angle);
			}
			else if (gimbal_set_control->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_ENCONDE)
			{
					//enconde模式下，电机编码角度控制
					GIMBAL_relative_angle_limit(&gimbal_set_control->gimbal_yaw_motor, &add_yaw_angle);
			}
			
	/****************** pitch电机角度期望relative_angle_set/absolute_angle_set限幅 ***************************************/
			if (gimbal_set_control->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_RAW)
			{
					//raw模式下，直接发送控制值
					gimbal_set_control->gimbal_pitch_motor.raw_cmd_current = add_pitch_angle;
			}
			else if (gimbal_set_control->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_GYRO)
			{
					//gyro模式下，陀螺仪角度控制
					GIMBAL_absolute_angle_limit(&gimbal_set_control->gimbal_pitch_motor, add_pitch_angle);
			}
			else if (gimbal_set_control->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_ENCONDE)
			{
					//enconde模式下，电机编码角度控制
					GIMBAL_relative_angle_limit(&gimbal_set_control->gimbal_pitch_motor, &add_pitch_angle);
			}
}
//陀螺仪 控制量限制
static void GIMBAL_absolute_angle_limit(Gimbal_Motor_t *gimbal_motor, fp32 add)
{
    static fp32 bias_angle; 
    static fp32 angle_set;
    if (gimbal_motor == NULL)
    {
        return;
    }
    //误差角度 = 绝对角度期望absolute_angle_set - 绝对角度反馈absolute_angle_set
    bias_angle = rad_format(gimbal_motor->absolute_angle_set - gimbal_motor->absolute_angle);
    //云台相对角度+ 误差角度 + 新增角度 如果大于 最大机械角度
    if (gimbal_motor->relative_angle + bias_angle + add > gimbal_motor->max_relative_angle)
    {
        //如果是往最大机械角度控制方向
        if (add > 0.0f)
        {
            //计算出一个最大的添加角度，
            add = gimbal_motor->max_relative_angle - gimbal_motor->relative_angle - bias_angle;
        }
    }
    else if (gimbal_motor->relative_angle + bias_angle + add < gimbal_motor->min_relative_angle)
    {
        if (add < 0.0f)
        {
            add = gimbal_motor->min_relative_angle - gimbal_motor->relative_angle - bias_angle;
        }
    }
    angle_set = gimbal_motor->absolute_angle_set;
    gimbal_motor->absolute_angle_set = rad_format(angle_set + add);
}

static void GIMBAL_relative_angle_limit(Gimbal_Motor_t *gimbal_motor, fp32 *add)
{
    if (gimbal_motor == NULL)
    {
        return;
    }
    gimbal_motor->relative_angle_set += *add;
    //是否超过最大 最小值
    if (gimbal_motor->relative_angle_set > gimbal_motor->max_relative_angle)
    {
        gimbal_motor->relative_angle_set = gimbal_motor->max_relative_angle;
    }
    else if (gimbal_motor->relative_angle_set < gimbal_motor->min_relative_angle)
    {
        gimbal_motor->relative_angle_set = gimbal_motor->min_relative_angle;
    }
		
}

/****************** 5. GIMBAL_Control_loop *******************************************************************************************/
/*************  云台控制状态使用不同控制pid **********/
static void GIMBAL_Control_loop(Gimbal_Control_t *gimbal_control_loop)
{
    if (gimbal_control_loop == NULL)
    {
        return;
    }
	/************* yaw云台电机不同模式对于不同的控制函数 *************/
    if (gimbal_control_loop->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_RAW)
    {
        //raw控制
        gimbal_motor_raw_angle_control(&gimbal_control_loop->gimbal_yaw_motor);
    }
    else if (gimbal_control_loop->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_GYRO)
    {
        //底盘随动模式 期望为absolute_angle_set，反馈为absolute_angle
        gimbal_motor_absolute_angle_control(&gimbal_control_loop->gimbal_yaw_motor);
    }
    else if (gimbal_control_loop->gimbal_yaw_motor.gimbal_motor_mode == GIMBAL_MOTOR_ENCONDE)
    {
        //底盘不随动模式 期望为relative_angle_set，反馈为relative_angle
        gimbal_motor_relative_angle_control(&gimbal_control_loop->gimbal_yaw_motor);
    }

	/************* pitch云台电机不同模式对于不同的控制函数 *************/
    if (gimbal_control_loop->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_RAW)
    {
        //raw控制
        gimbal_motor_raw_angle_control(&gimbal_control_loop->gimbal_pitch_motor);
    }
    else if (gimbal_control_loop->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_GYRO)
    {
        //底盘随动模式
        gimbal_motor_absolute_angle_control(&gimbal_control_loop->gimbal_pitch_motor);
    }
    else if (gimbal_control_loop->gimbal_pitch_motor.gimbal_motor_mode == GIMBAL_MOTOR_ENCONDE)
    {
        //底盘不随动模式
        gimbal_motor_relative_angle_control(&gimbal_control_loop->gimbal_pitch_motor);
    }
}

/*************  GIMBAL_Control_loop()中根据遥控器Switch的值来调用不同的控制函数 **********/
	//GIMBAL_MOTOR_GYRO模式时调用
static void gimbal_motor_absolute_angle_control(Gimbal_Motor_t *gimbal_motor)
{
    if (gimbal_motor == NULL)
    {
        return;
    }
    
  /******************* yaw轴云台串级pid调试 ***************************/
    //角度环外环	位置式
    gimbal_motor->motor_gyro_set = GIMBAL_PID_Calc(&gimbal_motor->gimbal_motor_absolute_angle_pid,
																										gimbal_motor->absolute_angle, gimbal_motor->absolute_angle_set, gimbal_motor->motor_gyro);
    //角速度环内环 位置式
		gimbal_motor->current_set = PID_Calc(&gimbal_motor->gimbal_motor_gyro_pid, gimbal_motor->motor_gyro, gimbal_motor->motor_gyro_set);
    //控制值赋值
    gimbal_motor->given_current = (int16_t)(gimbal_motor->current_set);
}

	//GIMBAL_MOTOR_ENCONDE模式时调用
static void gimbal_motor_relative_angle_control(Gimbal_Motor_t *gimbal_motor)
{
    if (gimbal_motor == NULL)
    {
        return;
    }

  /******************* yaw轴云台串级pid调试 ***************************/
    //角度环外环	
		gimbal_motor->motor_gyro_set = GIMBAL_PID_Calc(&gimbal_motor->gimbal_motor_relative_angle_pid,
																										gimbal_motor->relative_angle, gimbal_motor->relative_angle_set, gimbal_motor->motor_gyro);
    //角速度环内环
		gimbal_motor->current_set = PID_Calc(&gimbal_motor->gimbal_motor_gyro_pid, gimbal_motor->motor_gyro, gimbal_motor->motor_gyro_set);
    //控制值赋值
    gimbal_motor->given_current = (int16_t)(gimbal_motor->current_set);
}

static void gimbal_motor_raw_angle_control(Gimbal_Motor_t *gimbal_motor)
{
    if (gimbal_motor == NULL)
    {
        return;
    }
    gimbal_motor->current_set = gimbal_motor->raw_cmd_current;
    gimbal_motor->given_current = (int16_t)(gimbal_motor->current_set);
}




static void GIMBAL_PID_Init(Gimbal_PID_t *pid, fp32 maxout, fp32 max_iout, fp32 kp, fp32 ki, fp32 kd)
{
    if (pid == NULL)
    {
        return;
    }
    pid->kp = kp;
    pid->ki = ki;
    pid->kd = kd;

    pid->err = 0.0f;
    pid->get = 0.0f;

    pid->max_iout = max_iout;
    pid->max_out = maxout;
}
static fp32 GIMBAL_PID_Calc(Gimbal_PID_t *pid, fp32 get, fp32 set, fp32 error_delta)
{
    fp32 err;
    if (pid == NULL)
    {
        return 0.0f;
    }
    pid->get = get;
    pid->set = set;

    err = set - get;
    pid->err = rad_format(err);
    pid->Pout = pid->kp * pid->err;
    pid->Iout += pid->ki * pid->err;
    pid->Dout = pid->kd * error_delta;
    abs_limit(&pid->Iout, pid->max_iout);
    pid->out = pid->Pout + pid->Iout + pid->Dout;
    abs_limit(&pid->out, pid->max_out);
    return pid->out;
}

//pid数据清理
static void Gimbal_PID_clear(Gimbal_PID_t *gimbal_pid_clear)
{
    if (gimbal_pid_clear == NULL)
    {
        return;
    }
    gimbal_pid_clear->err = gimbal_pid_clear->set = gimbal_pid_clear->get = 0.0f;
    gimbal_pid_clear->out = gimbal_pid_clear->Pout = gimbal_pid_clear->Iout = gimbal_pid_clear->Dout = 0.0f;
}
